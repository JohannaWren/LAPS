---
title: "Plotting OceanParcel trajectories"
author: Johanna LK Wren
date: June 11, 2021
output:
  html_notebook:
    theme: flatly
    toc: true
    toc_float:
      collapsed: false
      tod_depth: 3
---

```{r setup, include=FALSE}
#knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = '~/Desktop/')  # this sets the default working directory for your script. Change it to fit the folder you are working in
```

# Description
This code takes a trajectory file generated by OceanParcels and plots trajectories and makes a series of images for use in a gif. 
```{r}
library(ncdf4)
library(lubridate)
library(ggplot2)
library(ggquiver)
library(dplyr)
library(maptools)
```

# Read in trajectory file
The OceanParcls output file consists of lat, lon, depth, and time for each particle. One column is one particle, the number of rows is number of time steps. 
```{r}
# Read trajectory file
dat <- nc_open('LAPS_n10_pld365_25m_nday730_01012000.nc')
lo <- ncvar_get(dat, 'lon')
la <- ncvar_get(dat, 'lat')
z <- ncvar_get(dat, 'z')
a <- ncvar_get(dat, 'age')
i <- ncvar_get(dat, 'trajectory')
site <- ncvar_get(dat, 'releaseSite')
t  <- ncvar_get(dat, 'time')
tunit <- dat$var$time$units
nc_close(dat)

# Convert into vectors and merge data
lon <- as.vector(lo)
lat <- as.vector(la)
depth <- as.vector(z)
tvec <- as.vector(t)
age <- as.vector(a)
id <- as.vector(i)
site <- as.vector(site)
```

# Convert data to date time
Time is in seconds from whatever start date the OceanParcels simulation started at so best to pull that info from the ncdf file.

Using POSIX here because it best converts from seconds to a date with a time
```{r}
tustr <- strsplit(tunit, " ")
stime <- as.POSIXct(unlist(tustr)[3])
time <- as.POSIXct(tvec, origin=stime)
```

# Merge dataset into a data frame
Merge together lon, lat, time, and a particle index into a data frame for plotting
```{r}
# Merge data
traj <- data.frame(id, lon, lat, depth, age, time, site)
#traj$time <- time

# Create new variables
ntraj <- dim(lo)[2]
ntime <- dim(lo)[1]
traj$particle <- rep(1:ntraj,each=ntime)
head(traj)

#rm(lo, la, z, a,i,site,t,tunit,lon,lat,depth, tvec,age,id)
```
## Make a data frame with the start locations of each trajectory
```{r}
# First location in the trajectory file
#pts2 <- data.frame(lon=lo[1,], lat=la[1,])
# Alternatively, use the release sites
pts <- read.csv('LAPS_release_sites.csv', header=T)
```

# Map data
Making two kinds of plots here, one trajectory plot and one with points. Making common elements first

## Generate 'support' files
### Make the land polygons
Low res version, use 'world2Hires' for higher resolution coastline data. This is a convoluted way of doing this, making a shape object first, then turning into a data frame for ggolot to read, but it works nicely. 

Uses the spatial extent of the trajectories to get the coastline data. I didn't buffer the range since ggplot2 adds a bit around the axes when it plots. 

If your ncdf file is in east/west, use the `world` map. The 2 int he name refers to the 360 degree long map, without the 2 you get the +/- 180 degree long map. 
```{r}
lonRange <- range(lo, na.rm=T)
latRange <- range(la, na.rm=T)
projec <- CRS("+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0")
land <- maps::map('world2', fill=TRUE, xlim=lonRange, ylim=latRange, plot=FALSE)
ids <- sapply(strsplit(land$names, ":"), function(x) x[1])
bPols <- map2SpatialPolygons(land, IDs=ids, proj4string=projec)
hi <- fortify(bPols)
```

### Make a color palette
It's a slightly more muted version of 'jetcolors' from MATLAB, and a bit more vibrant than R's 'Spectral' 
```{r}
# Make color palette for vector speeds and trajectories
myCol <- rev(c('#EE1B27', '#F54C20', '#F2E004', '#60BB49', '#2EB5E8', '#3851A4'))
```

## Trajectory map
Make a plain map with points for start locations (generated from the first line in the ncdf file) as points, trajectories in different colors, and land as light gray with a Mercator projection. 

If you want to color the trajectories after date, just change `geom_path()` to `color=time` 

Not all start locations are included. For some reason it seem to be only particles that are not removed that are included in the OceanParcels output file.  

```{r}
# Full scale map with particles colored after release site
ggplot() +
  geom_map(map=hi, data=hi, aes(long, lat, map_id=id), fill='darkgray', color='gray50') +
  coord_quickmap(xlim=lonRange, ylim=latRange) +
  geom_path(data=traj, aes(lon, lat, group=id, color=site), show.legend=F, alpha=0.5) +
  scale_color_gradientn(colors=myCol) +
  geom_point(data=pts, aes(Lon, Lat), pch=19, cex=0.5) +
  theme_bw() +
  theme(panel.grid=element_blank()) +
  xlab('Longitude') +
  ylab('Latitude')

# Zoomed in map with particles colored after date
as.Date_origin <- function(x){
  as.Date(x, origin = '1970-01-01')
}
ggplot() +
  geom_map(map=hi, data=hi, aes(long, lat, map_id=id), fill='darkgray', color='gray50') +
  coord_quickmap(xlim=c(165,168), ylim=c(18,20)) +
  geom_path(data=traj, aes(lon, lat, group=id, color=as.integer(time)), show.legend=F, alpha=0.5) +
  scale_color_gradientn(colors=myCol, labels=as.Date_origin) +
  geom_point(data=pts, aes(Lon, Lat), pch=19, cex=0.5) +
  theme_bw() +
  theme(panel.grid=element_blank()) +
  xlab('Longitude') +
  ylab('Latitude')
```

Make plots by site since there is a lot of overplotting in the above figures
```{r}
pld = 365
p1 <- list()
for (i in 1:12) {
  traj2 <- traj %>% filter(age==86400*pld, site==i)
  p1[[i]] <- ggplot() +
    geom_map(map=hi, data=hi, aes(map_id=id), fill='darkgray', color='gray50') +
    coord_quickmap(xlim=lonRange, ylim=latRange) + 
    stat_density2d(data=traj2, aes(lon, lat, fill=..level..), alpha=0.5, geom='polygon') + 
    scale_fill_viridis_c() +
    theme_bw() +
    geom_point(data=pts[which(pts$Site == i),], aes(Lon, Lat), size=1) +
    theme(panel.grid=element_blank()) +
    xlab('Longitude') +
    ylab('Latitude') + 
    ggtitle(paste0(sites[which(sites$site == i),2], ' - ', pld, ' PLD'))
 #ggsave(filename=paste0('Density_', i, '.png'), plot=p1, width=10, height=6, units='in', dpi=300)
}
png(paste0('densityAll_PLD', pld, '.png'), width=10, height=13, res=300, units='in')
grid.arrange(p1[[1]], p1[[2]], p1[[3]], p1[[4]], p1[[5]], p1[[6]], p1[[7]], p1[[8]],p1[[9]], p1[[10]], p1[[11]], p1[[12]], ncol=2)
dev.off()

p2 <- list()
for (i in 1:12) {
  traj2 <- traj %>% filter(age<=86400*pld, site==i)
  p2[[i]] <- ggplot() +
    geom_map(map=hi, data=hi, aes(map_id=id), fill='darkgray', color='gray50') +
    coord_quickmap(xlim=lonRange, ylim=latRange) + 
    geom_path(data=traj2, aes(lon, lat, group=id), color=colorRampPalette(myCol)(12)[i], show.legend=F, alpha=0.5) +
    theme_bw() +
    geom_point(data=pts[which(pts$Site == i),], aes(Lon, Lat), size=1) +
    theme(panel.grid=element_blank()) +
    xlab('Longitude') +
    ylab('Latitude') + 
    ggtitle(paste0(sites[which(sites$site == i),2], ' - ', pld, ' PLD'))
}
png(paste0('trajectoryAll_PLD', pld, '.png'), width=10, height=13, res=300, units='in')
grid.arrange(p2[[1]], p2[[2]], p2[[3]], p2[[4]], p2[[5]], p2[[6]], p2[[7]], p2[[8]],p2[[9]], p2[[10]], p2[[11]], p2[[12]], ncol=2)
dev.off()
```


```{r}
ids <- traj %>% filter(unbeachN == 1) %>% distinct(id)
for (i in seq_along(ids[,1])) {
  trajSub <- filter(traj, id == ids[i,])
  
  a <- ggplot() +
    geom_map(map=hi, data=hi, aes(long, lat, map_id=id), fill='darkgray', color='gray50') +
    coord_quickmap(xlim=lonRange, ylim=latRange) +
    geom_path(data=trajSub, aes(lon, lat, group=id, color=factor(id)), show.legend=F) +
    geom_point(data=pts, aes(V2, V1), pch=19, cex=0.5) +
    theme_bw() +
    theme(panel.grid=element_blank()) +
    xlab('Longitude') +
    ylab('Latitude')
  
  print(a)
  
  readline(prompt="Press [enter] to continue")
}
```

# This is to make daily files with locations of particles - skipping this for now but keeping the code. 
## Current vector map with particles
### Read in current data
Generating a function here that takes a netcdf with u and v velocities used in the OceanParcels simulation and makes a ggplot friendly file for use to make the quiver plot. 
```{r eval=FALSE, include=FALSE}
# Trying my hand at writing the below code in functions instead so don't need the huge block of code and to make it easier if sonething fails

loadCurrents <- function(inFile, lonVar, latVar, uVar, vVar, timeVar) {
  # Read in current files
  cur <- nc_open(inFile)
  Lat <- ncvar_get(cur, latVar)
  Lon <- ncvar_get(cur, lonVar)
  u <- ncvar_get(cur, uVar)
  v <- ncvar_get(cur, vVar)
  tcur <- ncvar_get(cur, timeVar)
  tcunit <- cur$dim$TIME$units
  speed <- sqrt(u^2 + v^2)
  nc_close(cur)
  
  # Convert time to date for current files.
  # I put in a loop to try and correct for various time formats. POSIX needs the time in seconds since the specified date, so if time in the ncdf file is listed in hour or minutes we correct for that
  tcustr <- strsplit(tcunit, " ")
  sctime <- as.POSIXct(unlist(tcustr)[3])
  if (unlist(tcustr)[1] == "hours") {
    tcur <- tcur*(60*60)
  } else if (unlist(tcustr)[1] == "minutes") {
    tcur <- tcur*(60)
  }
  ctime <- as.POSIXct(tcur, origin=sctime)
  
  # space current vectors out for prettier plotting. Not regridding here, just picking every n vectors. 
  xind <- seq.int(1L, length(Lon), 6L)
  yind <- seq.int(1L, length(Lat), 6L)
  
  # choose depth layer for current vectors (as an index).
  # currently uses the shallowest depth from the trajectories file 
  idx <- unique(as.vector(z))
  depth <- idx[1]
  
  ## Create a data frame for the currents that can be used with quiver. 
  # Data contains longitude, latitude, u, v, and the current speed. 
  # This data is subset to show only every 6 current vectors for clarity when plotting
  # Put data into data frame for ggplot
  lonlat <- expand.grid(lon=Lon[xind], lat=Lat[yind])
  # These if loops are for differently dimensioned current files (with or without depth layers).
  if (length(dim(u)) == 3) {
    cdata <- data.frame(lon=lonlat$lon, lat=lonlat$lat, u=as.vector(u[xind,yind,depth]), v=as.vector(v[xind,yind,depth]), speed=as.vector(speed[xind,yind,depth]))
  } else if (length(dim(u)) == 2) {
    cdata <- data.frame(lon=lonlat$lon, lat=lonlat$lat, u=as.vector(u[xind,yind]), v=as.vector(v[xind,yind]), speed=as.vector(speed[xind,yind]))
  } else {
    print('Dimensions of the velocity field are non-standard. Fix manually in code!')
  }
  cdata <- cdata %>% filter(between(lon, min(Lon), max(Lon)) & between(lat, min(Lat), max(Lat)))

  return(cdata)
}
```

### Define plotting function
This is a ggplot that makes a quiver map with particles locations. The arrows are colored after the current speed, and the color scale is fixed after the highest velocity in the time series. 

I really don't like ggplot but for this plot it was easier than having to mess with scaling of arrows in base plot. 
```{r eval=FALSE, include=FALSE}
quiverPlot <- function(plotfile, hi, cdata, trajPlot, timeStamp, myCol, minmax) {
  ggplot() +
    geom_map(map=hi, data=hi, aes(long, lat, map_id=id), fill='darkgray', color='gray50') +
    geom_quiver(data=cdata, aes(lon, lat, u=u, v=v, color=speed), center=T, lwd=1) +
    geom_point(data=trajPlot, aes(lon, lat), pch=19, cex=1.5) +
    scale_color_gradientn(colors=myCol, limits=c(0,1.1), name='Velocity \n(m/s)') +
    guides(color=guide_colorbar(barheight = 17, title.position='bottom')) +
    scale_x_continuous(expand=c(0,0), limits=c(min(cdata$lon)-0.2, max(cdata$lon)+0.2)) +
    scale_y_continuous(expand=c(0,0), limits=c(min(cdata$lat)-0.2, max(cdata$lat)+0.2)) +
    coord_map(projection='mercator') + 
    theme_bw() +
    theme(panel.grid=element_blank(),plot.title = element_text(hjust = 0.5)) +
    xlab('Longitude') +
    ylab('Latitude') +
    ggtitle(label=timeStamp)
  ggsave(plotfile, width=7, height=5, dpi=300, units='in')
}
```


### Generate daily maps

This loop calls the `loadCurrents` and `quiverPlot` functions defined above. 

Input for the `loadCurrents` function are a netcdf file with u and v data, and the names of the lat, lon, u, v, and time variables. 

The `quiverPlot` function needs the ouput from `loadCurrents` which is a ggplot friendly file with u and v data, and a file defining the min and max of the lat and lon variables, a color palette, the trajectory file and coastline data from earlier in the script. 

!!! You need to alter this bit of code to suit your needs if you switch up the files. The `currentFile`, `plotfile`, and all the variables for the `loadCurrents` function needs to be user specified !!!
```{r eval=FALSE, include=FALSE}
# This block loops and generates a figure
for (i in seq_along(unique(traj$time))) {
  # Format date for use as identifier in file names
  timeStamp <- traj$time[i]
  # Make timestamp for plot
  d <- format.Date(timeStamp, '%Y%m%d')
  
  # Make a subset of the trajectory file for the loopday
  trajPlot <- traj[which(traj$time == traj$time[i]),]
  
  # Generate input and output file names with dates in them
  currentFile <- paste('HYCOM_10m/HYCOMhawaii', d, '10m.nc', sep='_')
  plotfile <- sprintf('HawaiiReefWDiff_%03d.png', i)  # !!! This file name is hardcoded in the convert to gif section below, so make sure you update that if you change this file name!!!
  
  # Run the function that extracts the currents for plotting
  currents <- loadCurrents(currentFile, 'LON', 'LAT', 'EVEL', 'NVEL', 'TIME')
  
  # Run the function that makes and saves the plots
  quiverPlot(plotfile, hi, currents, trajPlot, timeStamp, myCol)
}
```

### Convert figures to an animated gif using ImageMagick

This is done outside R so you need to have ImageMagick installed on your computer. The second line removes all the individual images so you don't store them all. 
```{r}
system('convert -delay 20 HawaiiReefWDiff_*.png -loop 0 HawaiiReefDiff.gif')
```

Then we clean up the folder by removing all the individual images that made up the gif.
```{r}
# Clean up the individual images
system('rm HawaiiReefDiff_*.png')
```

